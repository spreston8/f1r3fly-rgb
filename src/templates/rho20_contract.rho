// Complete Rho20 Token Contract with State - CORRECTED VERSION
// Based on embers insert_signed.rho pattern with proper insertSigned format
//
// This is a fully working token contract that demonstrates:
// - Correct insertSigned registration for persistent contract deployment
// - State management with treeHashMap (all state in map, no separate channels)
// - Issue, transfer, and balance query operations
// - Proper URI binding so lookups work
//
// Template variables (replaced by executor.rs):
// - {{TICKER}}, {{NAME}}, {{TOTAL_SUPPLY}}, {{PRECISION}}
// - {{PUBLIC_KEY}}, {{SIGNATURE}}, {{VERSION}}, {{URI}}
// - {{DEPLOYER_PUBLIC_KEY}} (NEW: for issue() authorization)

new rl(`rho:registry:lookup`),
    rs(`rho:registry:insertSigned:secp256k1`),
    stdout(`rho:io:stdout`),
    abort(`rho:execution:abort`),
    devNull(`rho:io:devNull`),
    treeHashMapCh,
    balanceMapCh,
    prevEnvCh,
    initEnv,
    Rho20Token,
    executeTransfer,
    uriOut,
    secpVerify(`rho:crypto:secp256k1Verify`),
    blake2b256(`rho:crypto:blake2b256Hash`),
    deployerPubKeyCh,
    usedNoncesCh,
    utxoOwnersCh,
    utxoNoncesCh
in {
  // Check if contract already exists (Embers upgrade pattern)
  rl!(`{{URI}}`, *prevEnvCh) |
  
  for(@Nil <- prevEnvCh) {
    initEnv!()
  } |
  
  for(@(version, _) <- prevEnvCh) {
    if (version < {{VERSION}}) {
      initEnv!()
    }
  } |
  
  for(<- initEnv) {
    // Initialize treeHashMap for ALL state (balances + unallocated)
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |
    
    for(treeHashMap <- treeHashMapCh) {
      treeHashMap!("init", 3, *treeHashMapCh) |
      
      for(@balanceMap <- treeHashMapCh) {
        // CRITICAL: Initialize unallocated supply IN the map
        // This prevents race conditions and ensures persistence
        treeHashMap!("set", balanceMap, "unallocated", {{TOTAL_SUPPLY}}, *devNull) |
        
        // Store treeHashMap and map for persistent access (uses <<- peek)
        balanceMapCh!(*treeHashMap, balanceMap) |
        
              // Store deployer public key (from wallet's f1r3fly_public_key)
              // This is the ONLY key authorized to call issue()
              deployerPubKeyCh!("{{DEPLOYER_PUBLIC_KEY}}".hexToBytes()) |
              
              // Track used nonces for replay protection (starts as empty Set)
              // Must explicitly use Set() - {} is interpreted as Map!
              usedNoncesCh!(Set()) |
              
              // Track UTXO ownership: utxo -> owner_public_key
              utxoOwnersCh!({}) |
              
              // Track per-UTXO nonces for transfer authorization
              utxoNoncesCh!({}) |
        
        // =====================================================================
        // Method: getMetadata - Returns token metadata
        // =====================================================================
        contract Rho20Token(@"getMetadata", ret) = {
          ret!({
            "ticker": "{{TICKER}}",
            "name": "{{NAME}}",
            "supply": {{TOTAL_SUPPLY}},
            "decimals": {{PRECISION}}
          })
        } |
        
        // =====================================================================
        // Method: balanceOf - Query balance for an address
        // =====================================================================
        contract Rho20Token(@"balanceOf", @address, ret) = {
          new foundCh, notFoundCh in {
            for(treeHashMap, @currentMap <<- balanceMapCh) {
              treeHashMap!("getOrElse", currentMap, address, *foundCh, *notFoundCh)
            } |
            
            for(@balance <- foundCh) {
              ret!(balance)
            } |
            
            for(<- notFoundCh) {
              ret!(0)
            }
          }
        } |
        
        // =====================================================================
        // Method: ownerOf - Query the owner of a UTXO
        // =====================================================================
        // Returns the public key (as hex string) of the UTXO owner, or empty string if unowned
        //
        // Parameters:
        //   - address: UTXO identifier (e.g., "txid:vout" or "witness:hash:vout")
        //
        // Returns:
        //   - Hex-encoded public key string if owner exists
        //   - Empty string ("") if no owner registered for this address
        //
        // Use Cases:
        //   - Verify ownership after claim() migration
        //   - Debug ownership state
        //   - Validate transfer authorization logic
        //
        contract Rho20Token(@"ownerOf", @address, ret) = {
          for(@owners <<- utxoOwnersCh) {
            match owners.get(address) {
              Nil => {
                ret!("")
              }
              ownerPubKey => {
                ret!(ownerPubKey)
              }
            }
          }
        } |
        
        // =====================================================================
        // Method: issue - Allocate tokens from unallocated supply
        // =====================================================================
        // SECURED: Requires deployer signature + nonce for authorization
        //
        // Parameters:
        //   - recipient: UTXO identifier for token allocation
        //   - amount: Number of tokens to issue
        //   - recipientPubKey: Public key of the recipient (registered as owner)
        //   - nonce: Unique nonce for replay protection (must not have been used before)
        //   - signatureHex: Hex-encoded signature of (recipient, amount, nonce)
        //
        // Authorization:
        //   - Message: (recipient, amount, nonce) serialized to bytes
        //   - Hash: Blake2b-256 of message
        //   - Signature: ECDSA signature with secp256k1
        //   - Signer: Must match deployer public key stored at contract deployment
        //
        // Returns:
        //   - {"success": true, "balance": <amount>} on success
        //   - {"success": false, "error": <reason>} on failure
        contract Rho20Token(@"issue", @recipient, @amount, @recipientPubKey, @nonce, @signatureHex, ret) = {
          if (amount <= 0) {
            ret!({"success": false, "error": "Amount must be positive"})
          } else {
            new hashCh, verifyCh in {
              // Step 1: Hash the message (recipient, amount, nonce)
              // This must match the Rust signing code exactly
              blake2b256!((recipient, amount, nonce).toByteArray(), *hashCh) |
              
              // Step 2: Get deployer public key (peek - doesn't consume)
              for (@messageHash <- hashCh; @deployerPubKey <<- deployerPubKeyCh) {
                // Step 3: Verify signature
                // secpVerify expects: (hash, signature, publicKey, returnChannel)
                secpVerify!(messageHash, signatureHex.hexToBytes(), deployerPubKey, *verifyCh) |
                
                for (@isValid <- verifyCh) {
                  if (isValid) {
                    // Signature is valid - check nonce hasn't been used
                    for (@usedNonces <- usedNoncesCh) {
                      if (usedNonces.contains(nonce)) {
                        // Nonce was already used - reject (replay attack)
                        usedNoncesCh!(usedNonces) |  // Put nonces back
                        ret!({"success": false, "error": "Nonce already used"})
                      } else {
                        // Nonce is fresh - mark as used and proceed
                        // Use Set.union() to add new nonce to set
                        usedNoncesCh!(usedNonces.union(Set(nonce))) |
                        
                        // Execute issue logic (same as before)
                        new unallocFoundCh, unallocNotFoundCh in {
                          for(treeHashMap, @currentMap <<- balanceMapCh) {
                            // Get current unallocated from map
                            treeHashMap!("getOrElse", currentMap, "unallocated", *unallocFoundCh, *unallocNotFoundCh) |
                            
                            for(@currentUnallocated <- unallocFoundCh) {
                              if (amount <= currentUnallocated) {
                                // Update unallocated in map
                                treeHashMap!("set", currentMap, "unallocated", currentUnallocated - amount, *devNull) |
                                
                                // Update recipient balance
                                new balFoundCh, balNotFoundCh in {
                                  treeHashMap!("getOrElse", currentMap, recipient, *balFoundCh, *balNotFoundCh) |
                                  
                                  for(@existingBalance <- balFoundCh) {
                                    // Add to existing balance
                                    treeHashMap!("set", currentMap, recipient, existingBalance + amount, *devNull) |
                                    
                                    // Register UTXO owner (store recipient public key)
                                    for(@owners <- utxoOwnersCh) {
                                      utxoOwnersCh!(owners.set(recipient, recipientPubKey)) |
                                      ret!({"success": true, "balance": existingBalance + amount})
                                    }
                                  } |
                                  
                                  for(<- balNotFoundCh) {
                                    // Create new balance entry
                                    treeHashMap!("set", currentMap, recipient, amount, *devNull) |
                                    
                                    // Register UTXO owner (store recipient public key)
                                    for(@owners <- utxoOwnersCh) {
                                      utxoOwnersCh!(owners.set(recipient, recipientPubKey)) |
                                      ret!({"success": true, "balance": amount})
                                    }
                                  }
                                }
                              } else {
                                ret!({"success": false, "error": "Insufficient unallocated supply", "available": currentUnallocated, "requested": amount})
                              }
                            } |
                            
                            for(<- unallocNotFoundCh) {
                              ret!({"success": false, "error": "Contract not initialized - unallocated supply not found"})
                            }
                          }
                        }
                      }
                    }
                  } else {
                    // Signature verification failed
                    ret!({"success": false, "error": "Invalid signature - unauthorized"})
                  }
                }
              }
            }
          }
        } |
        
        // =====================================================================
        // Method: transfer - Transfer tokens between addresses
        // =====================================================================
        // SECURED: Requires sender signature + nonce for authorization
        //
        // Parameters:
        //   - from: UTXO identifier sending tokens
        //   - to: UTXO identifier receiving tokens
        //   - amount: Number of tokens to transfer
        //   - toPubKey: Public key of recipient (registered as new owner)
        //   - nonce: Unique nonce for replay protection (per-UTXO)
        //   - fromSignatureHex: Hex-encoded signature from sender
        //
        // Authorization:
        //   - Message: (from, to, amount, nonce) serialized to bytes
        //   - Hash: Blake2b-256 of message
        //   - Signature: ECDSA signature with secp256k1
        //   - Signer: Must match owner public key registered for 'from' UTXO
        //
        // Returns:
        //   - {"success": true, "from_balance": <amount>, "to_balance": <amount>} on success
        //   - {"success": false, "error": <reason>} on failure
        contract Rho20Token(@"transfer", @from, @to, @amount, @toPubKey, @nonce, @fromSignatureHex, ret) = {
          if (amount <= 0) {
            ret!({"success": false, "error": "Amount must be positive"})
          } else {
            // Step 1: Get owner of 'from' UTXO
            new ownerFoundCh, ownerNotFoundCh in {
              for(@owners <<- utxoOwnersCh) {
                match owners.get(from) {
                  Nil => {
                    ret!({"success": false, "error": "Unknown sender - no registered owner"})
                  }
                  ownerPubKey => {
                    // Step 2: Verify signature
                    new hashCh, verifyCh in {
                      blake2b256!((from, to, amount, nonce).toByteArray(), *hashCh) |
                      
                      for(@messageHash <- hashCh) {
                        secpVerify!(messageHash, fromSignatureHex.hexToBytes(), ownerPubKey.hexToBytes(), *verifyCh) |
                        
                        for(@isValid <- verifyCh) {
                          if (isValid) {
                            // Step 3: Check nonce hasn't been used for this UTXO
                            for(@utxoNonces <- utxoNoncesCh) {
                              match utxoNonces.get(from) {
                                Nil => {
                                  // First transfer from this UTXO - no nonces used yet
                                  utxoNoncesCh!(utxoNonces.set(from, Set(nonce))) |
                                  
                                  // Proceed with transfer logic
                                  executeTransfer!(from, to, amount, toPubKey, *ret)
                                }
                                usedSet => {
                                  if (usedSet.contains(nonce)) {
                                    utxoNoncesCh!(utxoNonces) |  // Put nonces back
                                    ret!({"success": false, "error": "Nonce already used for this UTXO"})
                                  } else {
                                    // Mark nonce as used
                                    utxoNoncesCh!(utxoNonces.set(from, usedSet.union(Set(nonce)))) |
                                    
                                    // Proceed with transfer logic
                                    executeTransfer!(from, to, amount, toPubKey, *ret)
                                  }
                                }
                              }
                            }
                          } else {
                            ret!({"success": false, "error": "Invalid signature - unauthorized transfer"})
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |
        
        // =====================================================================
        // Helper: executeTransfer - Execute balance transfer with owner registration
        // =====================================================================
        // Called only after authorization passes (signature + nonce verified)
        // Handles balance updates and registers new owner for recipient UTXO
        contract executeTransfer(@from, @to, @amount, @toPubKey, ret) = {
          new fromFoundCh, fromNotFoundCh in {
            for(treeHashMap, @currentMap <<- balanceMapCh) {
              treeHashMap!("getOrElse", currentMap, from, *fromFoundCh, *fromNotFoundCh) |
              
              for(@fromBalance <- fromFoundCh) {
                if (fromBalance >= amount) {
                  // Deduct from sender
                  treeHashMap!("set", currentMap, from, fromBalance - amount, *devNull) |
                  
                  // Update recipient
                  new toFoundCh, toNotFoundCh in {
                    treeHashMap!("getOrElse", currentMap, to, *toFoundCh, *toNotFoundCh) |
                    
                    for(@toBalance <- toFoundCh) {
                      // Add to existing recipient balance
                      treeHashMap!("set", currentMap, to, toBalance + amount, *devNull) |
                      
                      // Register new owner for recipient UTXO
                      for(@owners <- utxoOwnersCh) {
                        utxoOwnersCh!(owners.set(to, toPubKey)) |
                        ret!({"success": true, "from_balance": fromBalance - amount, "to_balance": toBalance + amount})
                      }
                    } |
                    
                    for(<- toNotFoundCh) {
                      // Create new recipient balance
                      treeHashMap!("set", currentMap, to, amount, *devNull) |
                      
                      // Register new owner for recipient UTXO
                      for(@owners <- utxoOwnersCh) {
                        utxoOwnersCh!(owners.set(to, toPubKey)) |
                        ret!({"success": true, "from_balance": fromBalance - amount, "to_balance": amount})
                      }
                    }
                  }
                } else {
                  ret!({"success": false, "error": "Insufficient balance", "balance": fromBalance, "requested": amount})
                }
              } |
              
              for(<- fromNotFoundCh) {
                ret!({"success": false, "error": "Sender has no balance"})
              }
            }
          }
        } |
        
        // =====================================================================
        // METHOD: claim
        // =====================================================================
        // Migrate balance and ownership from witness_id to real UTXO
        //
        // Called by recipient after Bitcoin TX confirms to claim their balance
        //
        // Parameters:
        //   - witness_id: Temporary identifier (e.g. "witness:a3467636:0")
        //   - real_utxo: Actual Bitcoin UTXO (e.g. "9b7b09e4cd136021:0")
        //   - claimantSignatureHex: Signature proving ownership
        //
        // Returns:
        //   - {"success": true, "migrated_balance": <amount>} on success
        //   - {"success": false, "error": <reason>} on failure
        //
        // Security:
        //   - Requires signature from registered owner of witness_id
        //   - Atomically migrates BOTH balance AND ownership
        //   - Prevents replay (consumes witness_id balance after migration)
        //
        contract Rho20Token(@"claim", @witness_id, @real_utxo, @claimantSignatureHex, ret) = {
          // Step 1: Get owner of witness_id
          for(@owners <<- utxoOwnersCh) {
            match owners.get(witness_id) {
              Nil => {
                ret!({"success": false, "error": "No owner registered for witness_id"})
              }
              ownerPubKey => {
                // Step 2: Verify signature
                // Message: (witness_id, real_utxo)
                new hashCh, verifyCh in {
                  blake2b256!((witness_id, real_utxo).toByteArray(), *hashCh) |
                  
                  for(@messageHash <- hashCh) {
                    secpVerify!(messageHash, claimantSignatureHex.hexToBytes(), ownerPubKey.hexToBytes(), *verifyCh) |
                    
                    for(@isValid <- verifyCh) {
                      if (isValid) {
                        // Step 3: Atomic migration of balance and ownership
                        // Get witness balance from treeHashMap
                        new witnessFoundCh, witnessNotFoundCh in {
                          for(treeHashMap, @currentMap <<- balanceMapCh) {
                            treeHashMap!("getOrElse", currentMap, witness_id, *witnessFoundCh, *witnessNotFoundCh) |
                            
                            for(@witnessBalance <- witnessFoundCh) {
                              if (witnessBalance <= 0) {
                                // Zero or negative balance at witness_id
                                ret!({"success": false, "error": "Zero or negative balance at witness_id", "balance": witnessBalance})
                              } else {
                                // ATOMIC MIGRATION:
                                // 1. Clear witness balance (set to 0)
                                // 2. Set real UTXO balance
                                // 3. Update ownership
                                
                                treeHashMap!("set", currentMap, witness_id, 0, *devNull) |
                                treeHashMap!("set", currentMap, real_utxo, witnessBalance, *devNull) |
                                
                                // Update ownership map
                                for(@currentOwners <- utxoOwnersCh) {
                                  utxoOwnersCh!(currentOwners.delete(witness_id).set(real_utxo, ownerPubKey)) |
                                  ret!({
                                    "success": true,
                                    "migrated_balance": witnessBalance,
                                    "from": witness_id,
                                    "to": real_utxo
                                  })
                                }
                              }
                            } |
                            
                            for(<- witnessNotFoundCh) {
                              // No balance at witness_id (already claimed or never existed)
                              ret!({"success": false, "error": "No balance at witness_id"})
                            }
                          }
                        }
                      } else {
                        ret!({"success": false, "error": "Invalid signature - unauthorized claim"})
                      }
                    }
                  }
                }
              }
            }
          }
        } |
        
        // =====================================================================
        // Register with insertSigned - CORRECT FORMAT (from Registry.rho)
        // =====================================================================
        // API: insertSigned(@pubKeyBytes, @(version, data), @sig, ret)
        // - pubKeyBytes: Public key for URI generation
        // - (version, data): Tuple with version number and contract bundle
        // - sig: Signature of (timestamp, deployerPubKey, version)
        // - ret: Return channel (returns URI or Nil)
        //
        // insertSigned automatically stores (version, data) at the URI!
        // No need for manual @uri!(...) binding.
        
        rs!(
          "{{PUBLIC_KEY}}".hexToBytes(),
          ({{VERSION}}, bundle+{*Rho20Token}),
          "{{SIGNATURE}}".hexToBytes(),
          *uriOut
        ) |
        
        for(@Nil <- uriOut) {
          abort!("insertSigned failed - signature verification error")
        } |
        
        for(@uri <- uriOut) {
          stdout!(("Rho20 Token Registered", "URI:", uri, "Ticker:", "{{TICKER}}", "Supply:", {{TOTAL_SUPPLY}}))
        }
      }
    }
  }
}

# F1r3fly Integration Challenges & Solutions

**Document Purpose:** This document describes key technical challenges encountered during F1r3fly-RGB integration and their solutions. Use this as context when working with F1r3fly node interactions, Rholang contract deployment, and RSpace state queries.

**Last Updated:** November 6, 2025  
**Project:** F1r3fly-RGB Wallet

---

## Table of Contents

1. [Contract URI vs Registry URI Problem](#1-contract-uri-vs-registry-uri-problem)
2. [Phlo Problem in Deploys](#2-phlo-problem-in-deploys)
3. [HTTP vs gRPC Explore-Deploy Response Format](#3-http-vs-grpc-explore-deploy-response-format)
4. [Summary of Solutions](#4-summary-of-solutions)

---

## 1. Contract URI vs Registry URI Problem

### **Problem Description**

When deploying Rholang contracts to F1r3fly, there are **two different types of URIs** that developers must understand and use correctly:

#### **Contract URI (Unforgeable Name)**
- **Format:** `rho:rspace:abc123...` or similar internal RSpace identifier
- **Generated by:** The F1r3fly node when you deploy a contract
- **Scope:** Local to the RSpace tuplespace
- **Lifetime:** Ephemeral - lost when node restarts or blockchain reorganizes
- **Use case:** Direct channel communication within a single deploy

**Example:**
```rholang
new myCh in {
  myCh!("Hello")  // myCh is a contract URI (unforgeable name)
}
```

The `myCh` channel gets an internal URI like `rho:rspace:abc123...` but you can't use this URI from other deploys or after node restarts.

#### **Registry URI (Persistent Identifier)**
- **Format:** `rho:id:xyz789...` (from `insertSigned` or `rho:registry:insertArbitrary`)
- **Generated by:** The system registry after successful registration
- **Scope:** Global - accessible from any deploy
- **Lifetime:** Persistent - survives node restarts and blockchain reorgs
- **Use case:** Persistent contract references, cross-deploy communication

**Example:**
```rholang
new rl(`rho:registry:lookup`), myCh in {
  rl!(`rho:id:xyz789...`, *myCh) |  // Registry URI - persistent and global
  for(@contract <- myCh) {
    // Use the contract
  }
}
```

### **The Problem We Encountered**

In our RGB storage contract (`rgb_state_storage.rho`), we initially tried to:

1. Deploy the contract with `exploratory_deploy` (read-only)
2. Extract the contract URI from the response
3. Use that URI to call contract methods from other deploys

**This failed because:**
- Exploratory deploys don't persist state
- Contract URIs are not registered in the global registry
- Subsequent deploys couldn't find the contract

**Error symptoms:**
```
Error: Contract not found
Error: Channel lookup failed
Error: No data on channel rho:rspace:abc123...
```

### **Solution: Use `insertSigned` for Persistent Registry URIs**

We switched to using **`insertSigned`** which:
1. Deploys the contract to the blockchain (persistent)
2. Registers it in the system registry
3. Returns a **registry URI** (`rho:id:...`)
4. Makes the contract globally accessible

**Implementation:**

```rholang
// rgb_state_storage.rho - Deploy with insertSigned
new
  rl(`rho:registry:lookup`),
  insertSignedCh,
  uriCh,
  contractMapCh,
  allocationMapCh,
  transitionMapCh,
  walletDescriptorMapCh,
  walletUtxosMapCh,
  RGBStorage
in {
  rl!(`rho:rchain:insertSigned:secp256k1`, *insertSignedCh) |
  
  for(@(_, insertSigned) <- insertSignedCh) {
    // Register all methods in the system registry
    insertSigned!(
      "storeContract".hexToBytes(),
      (9223372036854775807, bundle),  // timestamp, signature bundle
      *uriCh
    ) |
    
    for(@uri <- uriCh) {
      @uri!(*RGBStorage)  // Bind contract to registry URI
    } |
    
    // Contract implementation
    contract RGBStorage(@"storeContract", @contractId, @metadata, return) = {
      contractMapCh!(contractId, metadata) |
      return!({"success": true})
    }
  }
}
```

**Deployment process:**

```rust
// rust-client/src/connection_manager.rs
pub async fn deploy_with_timestamp(
    &self,
    rholang_code: &str,
    timestamp_millis: i64,
) -> Result<String, ConnectionError> {
    // Create signature bundle for insertSigned
    let signature = self.sign_deploy(timestamp_millis)?;
    
    // Deploy with timestamp that matches signature
    let deploy_id = self.api.exploratory_deploy(rholang_code).await?;
    
    Ok(deploy_id)
}
```

**Usage from other deploys:**

```rust
// wallet/src/firefly/client.rs
pub async fn store_contract(
    &self,
    contract_id: &str,
    metadata: ContractMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    let uris = self.get_rgb_uris()?;  // Get registry URIs
    
    let rholang_code = format!(
        r#"new rl(`rho:registry:lookup`), rgbCh, ack in {{
  rl!(`{}`, *rgbCh) |  // ‚Üê Registry URI (rho:id:xyz...)
  for(@(_, RGBStorage) <- rgbCh) {{
    @RGBStorage!("storeContract", "{}", {}, *ack)
  }}
}}"#,
        uris.store_contract,  // This is a registry URI
        contract_id,
        serde_json::to_string(&metadata)?
    );
    
    self.deploy(&rholang_code).await
}
```

### **Key Differences Summary**

| Aspect | Contract URI | Registry URI |
|--------|-------------|--------------|
| **Format** | `rho:rspace:abc123...` | `rho:id:xyz789...` |
| **Persistence** | Ephemeral | Persistent |
| **Scope** | Local deploy only | Global (all deploys) |
| **Registration** | Automatic (internal) | Explicit (`insertSigned`) |
| **Use Case** | Internal channels | Public contract APIs |
| **Survives Restart** | ‚ùå No | ‚úÖ Yes |

### **Deploy-Once Mechanism: Using Rust to Prevent Duplicate Deployments**

A critical aspect of working with registry URIs is ensuring the RGB storage contract is **deployed exactly once**. Deploying multiple times would create different registry URIs and fragment the state.

We use **Rust's `OnceLock` mechanism** to ensure thread-safe, single deployment:

#### **Implementation: `OnceLock` Pattern**

```rust
// wallet/tests/f1r3fly_test_utils.rs
use std::sync::OnceLock;

// Global static storage for RGB storage URIs
// OnceLock ensures this is initialized exactly once, even with multiple threads
static RGB_STORAGE_URIS: OnceLock<RgbStorageUris> = OnceLock::new();

pub async fn ensure_rgb_storage_deployed(
    client: &FireflyClient,
) -> anyhow::Result<&'static RgbStorageUris> {
    // Check if already deployed
    if let Some(uris) = RGB_STORAGE_URIS.get() {
        log::info!("‚úì RGB storage contract already deployed, reusing URIs");
        return Ok(uris);
    }
    
    log::info!("üöÄ Deploying RGB storage contract (first time)");
    
    // Load private key from environment
    let private_key = std::env::var("FIREFLY_PRIVATE_KEY")
        .expect("FIREFLY_PRIVATE_KEY must be set");
    
    // Generate Rholang code with insertSigned
    let (rholang_code, timestamp_millis) = generate_rgb_storage_rholang(&private_key)?;
    
    // Deploy with timestamp (required for insertSigned signature verification)
    let deploy_id = client
        .deploy_with_timestamp(&rholang_code, timestamp_millis)
        .await?;
    
    // Wait for deployment to be included in a block
    let _block_hash = client
        .wait_for_deploy(&deploy_id, 60)
        .await?;
    
    // Compute the deterministic registry URI from private key
    let uri = registry::compute_registry_uri_from_private_key(&private_key)?;
    
    // Create URIs struct (all methods use same base URI)
    let uris = RgbStorageUris {
        store_contract: uri.clone(),
        get_contract: uri.clone(),
        search_by_ticker: uri.clone(),
        store_allocation: uri.clone(),
        get_allocation: uri.clone(),
        record_transition: uri.clone(),
        get_transition: uri,
    };
    
    // Store in OnceLock - this will only succeed once
    // If multiple threads call this simultaneously, only one will initialize
    let cached_uris = RGB_STORAGE_URIS.get_or_init(|| uris);
    
    log::info!("‚úì RGB storage contract deployed and cached");
    
    Ok(cached_uris)
}
```

#### **How `OnceLock` Works**

**`OnceLock<T>`** is a thread-safe cell that can be written to only once:

1. **First call:** `get()` returns `None`, so we deploy the contract
2. **Deployment:** Contract is deployed with `insertSigned`, registry URI is computed
3. **Initialization:** `get_or_init()` stores the URIs in the `OnceLock`
4. **Subsequent calls:** `get()` returns `Some(uris)`, deployment is skipped

**Thread safety:**
- Multiple threads can call `ensure_rgb_storage_deployed()` simultaneously
- Only one thread will perform the deployment
- Other threads will block until deployment completes
- All threads receive the same URIs

#### **Deterministic URI Computation**

The registry URI is **deterministic** based on the private key:

```rust
// wallet/src/firefly/registry.rs
pub fn compute_registry_uri_from_private_key(
    private_key_hex: &str,
) -> anyhow::Result<String> {
    let secp = Secp256k1::new();
    let secret_key_bytes = hex::decode(private_key_hex)?;
    let secret_key = SecretKey::from_slice(&secret_key_bytes)?;
    
    // Derive public key from private key
    let public_key = PublicKey::from_secret_key(&secp, &secret_key);
    
    // Compute deterministic URI from public key
    Ok(public_key_to_uri(&public_key))
}

pub fn public_key_to_uri(public_key: &PublicKey) -> String {
    // 1. Serialize public key (uncompressed format)
    let pubkey_bytes = public_key.serialize_uncompressed();
    
    // 2. Hash with Blake2b-256
    let hash = Blake2b::<U32>::new().chain_update(&pubkey_bytes).finalize();
    
    // 3. Compute CRC14 checksum
    let crc_bytes = compute_crc14(&hash);
    
    // 4. Combine hash + CRC
    let mut full_key = Vec::with_capacity(34);
    full_key.extend_from_slice(hash.as_ref());
    full_key.push(crc_bytes[0]);
    full_key.push(crc_bytes[1] << 2);
    
    // 5. Encode with zbase32
    let encoded = zbase32::encode(&full_key, 270);
    
    // 6. Format as registry URI
    format!("rho:id:{}", encoded)
}
```

**Why this is important:**
- Same private key ‚Üí Same public key ‚Üí Same URI
- We can compute the URI **without querying the blockchain**
- No need to store URIs in a database
- URIs are reproducible across restarts

#### **Usage Pattern**

```rust
// In test setup
#[tokio::test]
async fn test_rgb_operation() {
    let config = FireflyTestConfig::from_env();
    let mut client = config.create_client();
    
    // Ensure contract is deployed (idempotent)
    let uris = ensure_rgb_storage_deployed(&client)
        .await
        .expect("Failed to deploy RGB storage");
    
    // Set URIs on client
    client.set_rgb_uris(uris.clone());
    
    // Now use client for RGB operations
    client.store_contract("rgb20_test", metadata).await?;
}
```

**First test run:**
```
üöÄ Deploying RGB storage contract (first time)
‚úì Contract deployed: rho:id:abc123...
‚úì RGB storage contract deployed and cached
```

**Subsequent test runs (same process):**
```
‚úì RGB storage contract already deployed, reusing URIs
```

#### **Production Deployment Strategy**

For production, we recommend a **two-phase approach**:

##### **Phase 1: One-Time Deployment (Manual)**

```bash
#!/bin/bash
# scripts/deploy_rgb_storage.sh

# Load environment
source .env

# Deploy contract
cargo run --bin deploy-rgb-storage

# Output:
# ‚úì RGB storage contract deployed
# Registry URI: rho:id:abc123def456...
# 
# Add this to your .env file:
# RGB_STORAGE_URI=rho:id:abc123def456...
```

##### **Phase 2: Runtime Usage (Automatic)**

```rust
// wallet/src/firefly/client.rs
impl FireflyClient {
    pub fn from_env() -> Result<Self, ConnectionError> {
        let connection = F1r3flyConnectionManager::from_env()?;
        
        // Load pre-deployed URI from environment
        let rgb_storage_uri = std::env::var("RGB_STORAGE_URI")
            .expect("RGB_STORAGE_URI must be set (deploy rgb_state_storage.rho first)");
        
        let rgb_uris = RgbStorageUris {
            store_contract: rgb_storage_uri.clone(),
            get_contract: rgb_storage_uri.clone(),
            search_by_ticker: rgb_storage_uri.clone(),
            store_allocation: rgb_storage_uri.clone(),
            get_allocation: rgb_storage_uri.clone(),
            record_transition: rgb_storage_uri.clone(),
            get_transition: rgb_storage_uri,
        };
        
        Ok(Self {
            connection,
            rgb_uris: Some(rgb_uris),
        })
    }
}
```

**Environment variables:**
```bash
# .env
FIREFLY_HOST=localhost
FIREFLY_GRPC_PORT=40401
FIREFLY_HTTP_PORT=40403
FIREFLY_PRIVATE_KEY=your_private_key_here

# Pre-deployed RGB storage contract URI (from Phase 1)
RGB_STORAGE_URI=rho:id:abc123def456...
```

#### **Alternative: Database Storage**

For multi-instance deployments, store URIs in a database:

```rust
use sqlx::PgPool;

pub async fn ensure_rgb_storage_deployed(
    client: &FireflyClient,
    db: &PgPool,
) -> anyhow::Result<RgbStorageUris> {
    // Check database first
    if let Some(uris) = load_uris_from_db(db).await? {
        return Ok(uris);
    }
    
    // Deploy if not found
    let uris = deploy_rgb_storage(client).await?;
    
    // Store in database
    save_uris_to_db(db, &uris).await?;
    
    Ok(uris)
}

async fn load_uris_from_db(db: &PgPool) -> anyhow::Result<Option<RgbStorageUris>> {
    let row = sqlx::query!(
        "SELECT registry_uri FROM rgb_storage_contracts WHERE active = true LIMIT 1"
    )
    .fetch_optional(db)
    .await?;
    
    Ok(row.map(|r| RgbStorageUris {
        store_contract: r.registry_uri.clone(),
        get_contract: r.registry_uri.clone(),
        // ... other URIs
    }))
}
```

#### **Registry URI Methods Reference**

The complete registry URI implementation is in `wallet/src/firefly/registry.rs`. Here are all the methods:

##### **1. `generate_insert_signed_signature()` - Create Signature for insertSigned**

```rust
/// Generate a signature for `insertSigned` registry operation
///
/// Creates a cryptographic signature required by F1r3fly's
/// `rho:registry:insertSigned:secp256k1` system contract.
///
/// # Arguments
/// * `key` - The secret key to sign with
/// * `timestamp` - The deployment timestamp
/// * `deployer` - The public key of the deployer
/// * `version` - The version number of the contract
///
/// # Returns
/// DER-encoded ECDSA signature as bytes
///
/// # Implementation
/// 1. Create a tuple: (timestamp_millis, deployer_pubkey_bytes, version)
/// 2. Encode as protobuf Par message
/// 3. Hash with Blake2b-256
/// 4. Sign with secp256k1
/// 5. Return DER-encoded signature
pub fn generate_insert_signed_signature(
    key: &SecretKey,
    timestamp: DateTime<Utc>,
    deployer: &PublicKey,
    version: i64,
) -> Vec<u8> {
    use f1r3fly_models::rhoapi;

    // Step 1: Create protobuf Par message with tuple (timestamp, pubkey, version)
    let par = rhoapi::Par {
        exprs: vec![rhoapi::Expr {
            expr_instance: Some(rhoapi::expr::ExprInstance::ETupleBody(rhoapi::ETuple {
                ps: vec![
                    // Timestamp as milliseconds
                    rhoapi::Par {
                        exprs: vec![rhoapi::Expr {
                            expr_instance: Some(rhoapi::expr::ExprInstance::GInt(
                                timestamp.timestamp_millis(),
                            )),
                        }],
                        ..Default::default()
                    },
                    // Public key as uncompressed bytes
                    rhoapi::Par {
                        exprs: vec![rhoapi::Expr {
                            expr_instance: Some(rhoapi::expr::ExprInstance::GByteArray(
                                deployer.serialize_uncompressed().into(),
                            )),
                        }],
                        ..Default::default()
                    },
                    // Version number
                    rhoapi::Par {
                        exprs: vec![rhoapi::Expr {
                            expr_instance: Some(rhoapi::expr::ExprInstance::GInt(version)),
                        }],
                        ..Default::default()
                    },
                ],
                ..Default::default()
            })),
        }],
        ..Default::default()
    }
    .encode_to_vec();

    // Step 2: Hash the protobuf with Blake2b-256
    let hash = Blake2b::<U32>::new().chain_update(par).finalize();
    
    // Step 3: Create secp256k1 message from hash
    let message = Message::from_digest(hash.into());

    // Step 4: Sign with secp256k1 and return DER-encoded signature
    Secp256k1::new()
        .sign_ecdsa(&message, key)
        .serialize_der()
        .to_vec()
}
```

**Usage:**
```rust
let secp = Secp256k1::new();
let secret_key = SecretKey::from_slice(&private_key_bytes)?;
let public_key = PublicKey::from_secret_key(&secp, &secret_key);
let timestamp = Utc::now();
let version = timestamp.timestamp_millis(); // Use timestamp as version

let signature = generate_insert_signed_signature(
    &secret_key,
    timestamp,
    &public_key,
    version
);

// signature is now a DER-encoded ECDSA signature (typically 70-72 bytes)
```

**Why this is needed:**
- F1r3fly's `insertSigned` requires cryptographic proof of ownership
- The signature proves you control the private key for the public key
- The tuple format `(timestamp, pubkey, version)` matches F1r3fly's verification logic
- Without a valid signature, `insertSigned` will reject the deployment

---

##### **2. `public_key_to_uri()` - Convert Public Key to Registry URI**

```rust
/// Convert a public key to a F1r3fly registry URI
///
/// The URI format is: `rho:id:<zbase32-encoded-hash-with-crc14>`
///
/// # Arguments
/// * `public_key` - The secp256k1 public key
///
/// # Returns
/// A deterministic URI string that can be used to look up the contract
pub fn public_key_to_uri(public_key: &PublicKey) -> String {
    // Step 1: Serialize public key (uncompressed format = 65 bytes)
    let pubkey_bytes = public_key.serialize_uncompressed();
    
    // Step 2: Hash with Blake2b-256 (produces 32 bytes)
    let hash = Blake2b::<U32>::new().chain_update(&pubkey_bytes).finalize();

    // Step 3: Compute CRC14 checksum (2 bytes)
    let crc_bytes = compute_crc14(&hash);

    // Step 4: Combine hash + CRC (34 bytes total)
    let mut full_key = Vec::with_capacity(34);
    full_key.extend_from_slice(hash.as_ref());      // 32 bytes
    full_key.push(crc_bytes[0]);                     // 1 byte
    full_key.push(crc_bytes[1] << 2);                // 1 byte (shifted)

    // Step 5: Encode with zbase32 (produces 54 characters)
    let encoded = zbase32::encode(&full_key, 270);

    // Step 6: Format as registry URI
    format!("rho:id:{}", encoded)
}
```

**Usage:**
```rust
let secp = Secp256k1::new();
let secret_key = SecretKey::from_slice(&private_key_bytes)?;
let public_key = PublicKey::from_secret_key(&secp, &secret_key);

let uri = public_key_to_uri(&public_key);
// uri = "rho:id:abc123def456..." (61 characters total)
```

**Output format:**
- Prefix: `rho:id:` (7 characters)
- Encoded data: 54 zbase32 characters
- Total: 61 characters
- Example: `rho:id:j6trahbg3yxuyznwdsjhqcf8aoq5z5p6k1qgx1e8zrn4d3qnxhco`

**Why zbase32?**
- Human-readable (no ambiguous characters like 0/O or 1/l)
- Case-insensitive
- URL-safe
- Standard encoding for RChain/F1r3fly URIs

---

##### **3. `compute_registry_uri_from_private_key()` - One-Step URI Computation**

```rust
/// Compute registry URI from private key
///
/// Derives the public key from the private key and computes the deterministic URI.
///
/// # Arguments
/// * `private_key_hex` - Hex-encoded private key
///
/// # Returns
/// The registry URI or an error if the private key is invalid
pub fn compute_registry_uri_from_private_key(
    private_key_hex: &str,
) -> anyhow::Result<String> {
    let secp = Secp256k1::new();
    
    // Decode hex private key
    let secret_key_bytes = hex::decode(private_key_hex)?;
    let secret_key = SecretKey::from_slice(&secret_key_bytes)?;
    
    // Derive public key
    let public_key = PublicKey::from_secret_key(&secp, &secret_key);

    // Compute URI
    Ok(public_key_to_uri(&public_key))
}
```

**Usage:**
```rust
let private_key_hex = "a1b2c3d4e5f6..."; // 64 hex characters (32 bytes)
let uri = compute_registry_uri_from_private_key(private_key_hex)?;
// uri = "rho:id:abc123def456..."
```

**This is the convenience method** - it combines:
1. Hex decoding
2. Private key parsing
3. Public key derivation
4. URI computation

**Use this when:**
- You have a private key and need the URI
- You want to verify what URI a private key will produce
- You're loading URIs from environment variables

---

##### **4. `compute_crc14()` - CRC14 Checksum (Internal)**

```rust
/// Compute CRC14 checksum for URI generation
///
/// Returns the CRC as little-endian bytes
fn compute_crc14(data: &[u8]) -> [u8; 2] {
    use crc::{Algorithm, Crc};

    // CRC14 algorithm parameters (F1r3fly-specific)
    const CRC14: Algorithm<u16> = Algorithm {
        width: 14,           // 14-bit CRC
        poly: 0x4805,        // Polynomial
        init: 0x0000,        // Initial value
        refin: false,        // No input reflection
        refout: false,       // No output reflection
        xorout: 0x0000,      // No XOR output
        check: 0,
        residue: 0x0000,
    };

    let crc = Crc::<u16>::new(&CRC14);
    let mut digest = crc.digest();
    digest.update(data);
    digest.finalize().to_le_bytes()  // Little-endian bytes
}
```

**Why CRC14?**
- Detects errors in URI transmission/storage
- 14-bit checksum provides good error detection
- Matches F1r3fly's URI format specification
- Little-endian encoding matches RChain conventions

---

##### **Complete Workflow Example**

Here's how all the methods work together to deploy a contract with `insertSigned`:

```rust
use chrono::Utc;
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use wallet::firefly::registry;

// 1. Load private key
let private_key_hex = std::env::var("FIREFLY_PRIVATE_KEY")?;
let secp = Secp256k1::new();
let secret_key_bytes = hex::decode(&private_key_hex)?;
let secret_key = SecretKey::from_slice(&secret_key_bytes)?;
let public_key = PublicKey::from_secret_key(&secp, &secret_key);

// 2. Generate timestamp and version
let timestamp = Utc::now();
let timestamp_millis = timestamp.timestamp_millis();
let version = timestamp_millis; // Use timestamp as version

// 3. Generate signature
let signature = registry::generate_insert_signed_signature(
    &secret_key,
    timestamp,
    &public_key,
    version
);

// 4. Compute URI (deterministic from public key)
let uri = registry::public_key_to_uri(&public_key);

// 5. Convert to hex for Rholang
let public_key_hex = hex::encode(public_key.serialize_uncompressed());
let signature_hex = hex::encode(&signature);

// 6. Build Rholang code with insertSigned
let rholang_code = format!(
    r#"new rl(`rho:registry:lookup`), insertSignedCh, uriCh in {{
  rl!(`rho:rchain:insertSigned:secp256k1`, *insertSignedCh) |
  for(@(_, insertSigned) <- insertSignedCh) {{
    insertSigned!(
      "{}".hexToBytes(),           // Public key
      ({}, "{}".hexToBytes(), {}), // (timestamp, signature, version)
      *uriCh
    ) |
    for(@uri <- uriCh) {{
      // Contract registered at: {}
      @uri!("Hello from RGB Storage!")
    }}
  }}
}}"#,
    public_key_hex,
    timestamp_millis,
    signature_hex,
    version,
    uri
);

// 7. Deploy with matching timestamp
firefly_client.deploy_with_timestamp(&rholang_code, timestamp_millis).await?;

// 8. Now the contract is accessible at the URI
println!("‚úì Contract deployed at: {}", uri);
```

**Key points:**
- The URI is **deterministic** - computed from public key before deployment
- The signature **proves ownership** - only the private key holder can generate it
- The timestamp **must match** - deploy timestamp must equal signature timestamp
- The contract is **globally accessible** - any deploy can look it up via the URI

---

#### **Key Mechanisms Summary**

| Mechanism | Purpose | Location |
|-----------|---------|----------|
| **`OnceLock<T>`** | Thread-safe single initialization | `wallet/tests/f1r3fly_test_utils.rs:208` |
| **`compute_registry_uri_from_private_key()`** | Compute URI from private key | `wallet/src/firefly/registry.rs:122` |
| **`public_key_to_uri()`** | Convert public key to URI | `wallet/src/firefly/registry.rs:97` |
| **`generate_insert_signed_signature()`** | Create insertSigned signature | `wallet/src/firefly/registry.rs:37` |
| **`compute_crc14()`** | CRC14 checksum for URIs | `wallet/src/firefly/registry.rs:136` |
| **`insertSigned`** | Persistent registry registration | `wallet/rholang/rgb_state_storage.rho` |
| **Environment variable** | Store URI for production | `.env` file |
| **Database storage** | Multi-instance coordination | Optional (not implemented) |

### **Best Practices**

1. **Use registry URIs for:**
   - RGB storage contracts
   - Any contract that needs to be called from multiple deploys
   - Contracts that need to survive node restarts
   - Public APIs

2. **Use contract URIs for:**
   - Temporary channels within a single deploy
   - Internal communication
   - One-time operations

3. **Always:**
   - Store registry URIs in your client configuration
   - Use `rho:registry:lookup` to resolve registry URIs
   - Verify registry URIs after deployment
   - Use `OnceLock` or similar mechanism to prevent duplicate deployments
   - Compute URIs deterministically from private keys when possible

---

## 2. Phlo Problem in Deploys

### **Problem Description**

F1r3fly uses **Phlo** (a resource accounting unit) to limit computational resources for deploys. Every deploy requires a phlo limit, and if the limit is too low, the deploy will fail.

**Error symptoms:**
```
Error: Insufficient phlo
Error: Phlo limit exceeded
Error: Deploy rejected: phlo limit too low
```

### **What is Phlo?**

- **Phlo** = "Photons of Light" (metaphorical unit of computation)
- Similar to Ethereum's "gas"
- Prevents infinite loops and DoS attacks
- Required for every deploy (both regular and exploratory)

**Phlo consumption depends on:**
- Code complexity (number of operations)
- Data size (larger payloads = more phlo)
- Registry lookups (each lookup costs phlo)
- State operations (reads/writes to RSpace)

### **The Problem We Encountered**

Our initial deploys used **hardcoded low phlo limits**:

```rust
// ‚ùå BAD: Hardcoded low phlo limit
let phlo_limit = 100_000;  // Too low for complex RGB operations
```

**This caused failures when:**
- Deploying large contracts (like `rgb_state_storage.rho`)
- Performing multiple registry lookups
- Storing large metadata objects
- Executing validation logic

**Specific failure case:**
```rust
// This deploy failed with "Insufficient phlo"
firefly_client.store_contract(
    &contract_id,
    ContractMetadata {
        ticker: "USDT",
        name: "Tether USD",
        precision: 8,
        total_supply: 1_000_000_000_000,  // Large number
        genesis_txid: "abc123...",         // 64 chars
        issuer_pubkey: "def456...",        // 66 chars
    }
).await?;
```

### **Solution: Use High Default Phlo Limits**

We increased the default phlo limit to a **very high value** that works for all RGB operations:

```rust
// rust-client/src/f1r3fly_api.rs
const DEFAULT_PHLO_LIMIT: i64 = 10_000_000_000;  // 10 billion phlo

pub async fn exploratory_deploy(
    &self,
    rholang_code: &str,
) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    let request = tonic::Request::new(ExploratoryDeployRequest {
        term: rholang_code.to_string(),
        phlo_limit: DEFAULT_PHLO_LIMIT,  // ‚Üê High default
        block_hash: String::new(),
    });
    
    let response = self.client.exploratory_deploy(request).await?;
    Ok(response.into_inner().result)
}
```

### **Why This Works**

1. **F1r3fly is not a production blockchain** (yet)
   - No real economic cost to phlo
   - Node operators don't charge for phlo
   - Focus is on functionality, not resource limits

2. **RGB operations are complex**
   - Validation logic requires many operations
   - State queries involve multiple registry lookups
   - Better to overprovision than fail mid-deploy

3. **Exploratory deploys are read-only**
   - Don't persist state
   - Can't cause permanent damage
   - Safe to use high phlo limits

### **Phlo Limit Guidelines**

| Operation Type | Recommended Phlo Limit | Rationale |
|----------------|------------------------|-----------|
| Simple query (1 lookup) | 1,000,000 | Minimal operations |
| Contract deployment | 10,000,000 | Complex initialization |
| RGB validation | 10,000,000,000 | Multiple lookups + logic |
| Large data storage | 10,000,000,000 | Payload size matters |
| **Default (all ops)** | **10,000,000,000** | **Safe for everything** |

### **Implementation in Our Codebase**

```rust
// rust-client/src/f1r3fly_api.rs
impl F1r3flyApi {
    /// Exploratory deploy (read-only query)
    pub async fn exploratory_deploy(
        &self,
        rholang_code: &str,
    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
        let request = tonic::Request::new(ExploratoryDeployRequest {
            term: rholang_code.to_string(),
            phlo_limit: 10_000_000_000,  // High default
            block_hash: String::new(),
        });
        
        let response = self.client.exploratory_deploy(request).await?;
        Ok(response.into_inner().result)
    }
    
    /// Regular deploy (writes to blockchain)
    pub async fn deploy(
        &self,
        rholang_code: &str,
    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
        let request = tonic::Request::new(DeployRequest {
            term: rholang_code.to_string(),
            phlo_limit: 10_000_000_000,  // High default
            phlo_price: 1,
            valid_after_block_number: 0,
        });
        
        let response = self.client.deploy(request).await?;
        Ok(response.into_inner().deploy_id)
    }
}
```

### **Future Considerations**

When F1r3fly moves to production:

1. **Implement dynamic phlo estimation**
   ```rust
   fn estimate_phlo(rholang_code: &str) -> i64 {
       let base = 1_000_000;
       let per_char = 1_000;
       let per_lookup = 100_000;
       
       let code_size = rholang_code.len() as i64;
       let lookup_count = rholang_code.matches("rho:registry:lookup").count() as i64;
       
       base + (code_size * per_char) + (lookup_count * per_lookup)
   }
   ```

2. **Add phlo limit configuration**
   ```rust
   // .env
   FIREFLY_PHLO_LIMIT=10000000000
   
   // Load from env
   let phlo_limit = std::env::var("FIREFLY_PHLO_LIMIT")
       .unwrap_or_else(|_| "10000000000".to_string())
       .parse::<i64>()?;
   ```

3. **Monitor actual phlo consumption**
   ```rust
   log::debug!("Deploy consumed {} phlo", response.phlo_used);
   ```

### **Key Takeaways**

- ‚úÖ **Use 10 billion phlo as default** for all RGB operations
- ‚úÖ **Don't worry about phlo costs** in development/regtest
- ‚úÖ **Overprovision rather than fail** mid-operation
- ‚ö†Ô∏è **Plan for dynamic estimation** when moving to production

---

## 3. HTTP vs gRPC Explore-Deploy Response Format

### **Problem Description**

F1r3fly provides **two different APIs** for exploratory deploys (read-only queries):

1. **gRPC API** (`ExploratoryDeploy` method)
2. **HTTP API** (`POST /api/explore-deploy`)

**The problem:** These APIs return **different response formats** for the same Rholang code, making it difficult to parse complex data structures.

### **Response Format Comparison**

#### **Scenario: Query RGB Contract Metadata**

**Rholang query:**
```rholang
new return, rl(`rho:registry:lookup`), rgbCh in {
  rl!(`rho:id:abc123...`, *rgbCh) |
  for(@(_, rgbStorage) <- rgbCh) {
    @rgbStorage!("getContract", "rgb20_xyz", *return)
  }
}
```

**Expected data:**
```json
{
  "success": true,
  "contract": {
    "ticker": "USDT",
    "name": "Tether USD",
    "precision": 8,
    "total_supply": 1000000000000
  }
}
```

---

#### **gRPC Response (Simplified)**

```rust
// rust-client/src/f1r3fly_api.rs
let response = client.exploratory_deploy(request).await?;
let result = response.into_inner().result;

println!("{}", result);
```

**Output:**
```
Complex expression with 2 fields
```

**That's it.** The gRPC response is a **simplified string** that loses all type information and nested structure.

**Why?**
- gRPC protobuf definitions use simplified serialization
- Complex Rholang types (ExprMap, ExprList, etc.) are flattened
- Designed for human readability, not programmatic parsing

---

#### **HTTP Response (Full JSON)**

```rust
// Direct HTTP call
let response = reqwest::Client::new()
    .post("http://localhost:40403/api/explore-deploy")
    .body(rholang_code)
    .header("Content-Type", "text/plain")
    .send()
    .await?;

let json: serde_json::Value = response.json().await?;
println!("{}", serde_json::to_string_pretty(&json)?);
```

**Output:**
```json
{
  "expr": [
    {
      "ExprMap": {
        "data": {
          "success": {
            "ExprBool": {
              "data": true
            }
          },
          "contract": {
            "ExprMap": {
              "data": {
                "ticker": {
                  "ExprString": {
                    "data": "USDT"
                  }
                },
                "name": {
                  "ExprString": {
                    "data": "Tether USD"
                  }
                },
                "precision": {
                  "ExprInt": {
                    "data": 8
                  }
                },
                "total_supply": {
                  "ExprInt": {
                    "data": 1000000000000
                  }
                }
              }
            }
          }
        }
      }
    }
  ],
  "block": {
    "blockHash": "abc123...",
    "blockNumber": 42,
    "timestamp": 1699999999
  }
}
```

**Full type information preserved!**

---

### **The Problem We Encountered**

We initially used **gRPC for all queries** because it was already integrated:

```rust
// ‚ùå BAD: Using gRPC for complex queries
pub async fn query_contract(
    &self,
    contract_id: &str,
) -> Result<ContractData, Box<dyn std::error::Error>> {
    let query_code = format!(/* ... */);
    
    // This returns "Complex expression with 2 fields"
    let result = self.connection.query(&query_code).await?;
    
    // ‚ùå Can't parse this!
    let contract_data: ContractData = serde_json::from_str(&result)?;
    // Error: expected value at line 1 column 1
}
```

**Failures:**
- ‚úÖ Simple queries worked (single strings/numbers)
- ‚ùå Complex queries failed (nested maps, arrays)
- ‚ùå All RGB operations failed (everything uses maps)

**Example failures:**
```rust
// ‚úÖ Works with gRPC (simple string)
query: "Hello world"
gRPC response: "Hello world"

// ‚ùå Fails with gRPC (complex map)
query: {"success": true, "data": {...}}
gRPC response: "Complex expression with 2 fields"
```

---

### **Solution: Use HTTP for Complex Queries, gRPC for Simple Deploys**

We created a **hybrid approach**:

1. **Use gRPC for simple deploys** (writes to blockchain)
   - Don't need to parse response
   - Just need deploy ID
   - gRPC is faster and more efficient

2. **Use HTTP for complex queries** (read-only with complex data)
   - Need full JSON structure
   - Parse nested Rholang types
   - Convert to Rust types

---

### **Implementation**

#### **1. Helper Function to Parse Rholang JSON**

```rust
// rust-client/src/rholang_helpers.rs
pub fn convert_rholang_to_json(
    value: &serde_json::Value
) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    // Recursively unwrap Rholang type wrappers
    if let Some(obj) = value.as_object() {
        // Handle ExprString
        if let Some(expr_string) = obj.get("ExprString") {
            if let Some(data) = expr_string.get("data") {
                return Ok(data.clone());
            }
        }
        
        // Handle ExprInt
        if let Some(expr_int) = obj.get("ExprInt") {
            if let Some(data) = expr_int.get("data") {
                return Ok(data.clone());
            }
        }
        
        // Handle ExprBool
        if let Some(expr_bool) = obj.get("ExprBool") {
            if let Some(data) = expr_bool.get("data") {
                return Ok(data.clone());
            }
        }
        
        // Handle ExprMap (recursive)
        if let Some(expr_map) = obj.get("ExprMap") {
            if let Some(data) = expr_map.get("data").and_then(|v| v.as_object()) {
                let mut result = serde_json::Map::new();
                for (key, value) in data {
                    result.insert(key.clone(), convert_rholang_to_json(value)?);
                }
                return Ok(serde_json::Value::Object(result));
            }
        }
        
        // Handle ExprList (recursive)
        if let Some(expr_list) = obj.get("ExprList") {
            if let Some(data) = expr_list.get("data").and_then(|v| v.as_array()) {
                let mut result = Vec::new();
                for item in data {
                    result.push(convert_rholang_to_json(item)?);
                }
                return Ok(serde_json::Value::Array(result));
            }
        }
    }
    
    Ok(value.clone())
}
```

---

#### **2. HTTP Query Method in FireflyClient**

```rust
// wallet/src/firefly/client.rs
impl FireflyClient {
    /// Helper method to query and parse Rholang response
    /// 
    /// NOTE: We use HTTP API directly here instead of ConnectionManager.query() because:
    /// - ConnectionManager.query() uses gRPC which returns simplified result strings
    /// - We need the full JSON response structure with expr arrays to parse complex Rholang types
    /// - The HTTP /api/explore-deploy endpoint returns the complete response with type information
    async fn query_and_parse_rholang(
        &self,
        query_code: &str,
    ) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        // Use HTTP API directly to get the full JSON response
        let http_client = reqwest::Client::new();
        let response = http_client
            .post(format!(
                "http://{}:{}/api/explore-deploy",
                self.node_host(),
                self.http_port()
            ))
            .body(query_code.to_string())
            .header("Content-Type", "text/plain")
            .send()
            .await?;
        
        if !response.status().is_success() {
            return Err(format!("HTTP error: {}", response.status()).into());
        }
        
        // Parse the full JSON response
        let json_response: serde_json::Value = response.json().await?;
        
        log::debug!("Raw JSON response: {}", 
            serde_json::to_string_pretty(&json_response)?);
        
        // Extract the expr data from the response
        // Response format: {"expr": [{"ExprMap": {...}}], "block": {...}}
        if let Some(expr_array) = json_response.get("expr")
            .and_then(|v| v.as_array()) 
        {
            if expr_array.is_empty() {
                return Err("No data returned from contract".into());
            }
            
            // Get the first expression (the return value)
            let rholang_expr = &expr_array[0];
            
            // Convert Rholang expression to plain JSON
            let plain_json = convert_rholang_to_json(rholang_expr)?;
            
            log::debug!("Converted to plain JSON: {}", 
                serde_json::to_string_pretty(&plain_json)?);
            
            Ok(plain_json)
        } else {
            Err("Invalid response format: missing 'expr' array".into())
        }
    }
}
```

---

#### **3. Usage in Query Methods**

```rust
// wallet/src/firefly/client.rs
pub async fn query_contract(
    &self,
    contract_id: &str,
    _at_block_hash: Option<&str>,
) -> Result<ContractData, Box<dyn std::error::Error>> {
    let uris = self.get_rgb_uris()?;
    
    // Generate Rholang query code
    let query_code = format!(
        r#"new return, rl(`rho:registry:lookup`), rgbCh in {{
  rl!(`{}`, *rgbCh) |
  for(@(_, rgbStorage) <- rgbCh) {{
    @rgbStorage!("getContract", "{}", *return)
  }}
}}"#,
        uris.get_contract,
        contract_id
    );
    
    // ‚úÖ Use HTTP API for complex query
    let plain_json = match self.query_and_parse_rholang(&query_code).await {
        Ok(json) => json,
        Err(e) => {
            return Ok(ContractData {
                success: false,
                contract: None,
                error: Some(e.to_string()),
            });
        }
    };
    
    // ‚úÖ Now we can parse the plain JSON
    match serde_json::from_value::<ContractData>(plain_json.clone()) {
        Ok(contract_data) => Ok(contract_data),
        Err(e) => {
            Ok(ContractData {
                success: false,
                contract: None,
                error: Some(format!("Failed to parse: {}", e)),
            })
        }
    }
}
```

---

#### **4. gRPC Still Used for Simple Deploys**

```rust
// rust-client/src/connection_manager.rs
impl F1r3flyConnectionManager {
    /// Deploy Rholang code (writes to blockchain)
    /// Uses gRPC because we only need the deploy ID, not complex response
    pub async fn deploy(
        &self,
        rholang_code: &str,
    ) -> Result<String, ConnectionError> {
        // ‚úÖ gRPC is fine here - just need deploy ID
        let deploy_id = self.api.deploy(rholang_code).await
            .map_err(|e| ConnectionError::DeployFailed(e.to_string()))?;
        Ok(deploy_id)
    }
    
    /// Query RSpace (exploratory deploy)
    /// Uses gRPC for simple queries, but caller should use HTTP for complex ones
    pub async fn query(
        &self,
        rholang_code: &str,
    ) -> Result<String, ConnectionError> {
        // ‚ö†Ô∏è gRPC returns simplified strings
        // For complex queries, use HTTP API directly
        let result = self.api.exploratory_deploy(rholang_code).await
            .map_err(|e| ConnectionError::QueryFailed(e.to_string()))?;
        Ok(result)
    }
}
```

---

### **When to Use Each API**

| Use Case | API | Reason |
|----------|-----|--------|
| **Deploy contract** | gRPC | Only need deploy ID |
| **Deploy with insertSigned** | gRPC | Only need deploy ID |
| **Simple query (string/number)** | gRPC | Fast, simple response |
| **Complex query (map/array)** | HTTP | Need full JSON structure |
| **RGB contract queries** | HTTP | Always return complex maps |
| **RGB allocation queries** | HTTP | Always return complex maps |
| **RGB transition queries** | HTTP | Always return complex maps |

---

### **Response Format Examples**

#### **Simple Query (gRPC OK)**

**Rholang:**
```rholang
new return in {
  return!("Hello World")
}
```

**gRPC Response:**
```
"Hello World"
```
‚úÖ Easy to parse

---

#### **Complex Query (HTTP Required)**

**Rholang:**
```rholang
new return in {
  return!({"name": "Alice", "balance": 1000, "active": true})
}
```

**gRPC Response:**
```
"Complex expression with 3 fields"
```
‚ùå Can't parse

**HTTP Response:**
```json
{
  "expr": [{
    "ExprMap": {
      "data": {
        "name": {"ExprString": {"data": "Alice"}},
        "balance": {"ExprInt": {"data": 1000}},
        "active": {"ExprBool": {"data": true}}
      }
    }
  }]
}
```
‚úÖ Full structure preserved

**After `convert_rholang_to_json()`:**
```json
{
  "name": "Alice",
  "balance": 1000,
  "active": true
}
```
‚úÖ Clean, parseable JSON

---

### **Key Takeaways**

- ‚úÖ **Use gRPC for deploys** (only need deploy ID)
- ‚úÖ **Use HTTP for complex queries** (need full JSON)
- ‚úÖ **Use `convert_rholang_to_json()`** to unwrap Rholang types
- ‚ö†Ô∏è **Don't use gRPC for RGB queries** (always complex maps)
- ‚ö†Ô∏è **HTTP is slower** but necessary for complex data

---

## 4. Summary of Solutions

### **Quick Reference Table**

| Problem | Solution | Implementation |
|---------|----------|----------------|
| **Contract URI not persistent** | Use `insertSigned` for registry URIs | `rgb_state_storage.rho` with `insertSigned` |
| **Phlo limit too low** | Use 10 billion phlo default | `DEFAULT_PHLO_LIMIT = 10_000_000_000` |
| **gRPC returns simplified strings** | Use HTTP for complex queries | `query_and_parse_rholang()` method |
| **Rholang types hard to parse** | Recursive unwrapping helper | `convert_rholang_to_json()` function |

---

### **Code Locations**

#### **Registry URI Management**
- **Contract:** `wallet/rholang/rgb_state_storage.rho`
- **Deployment:** `wallet/src/firefly/client.rs::deploy_with_timestamp()`
- **Usage:** `wallet/src/firefly/client.rs::store_contract()`

#### **Phlo Configuration**
- **gRPC API:** `rust-client/src/f1r3fly_api.rs`
- **Constant:** `DEFAULT_PHLO_LIMIT = 10_000_000_000`

#### **HTTP vs gRPC**
- **HTTP queries:** `wallet/src/firefly/client.rs::query_and_parse_rholang()`
- **gRPC deploys:** `rust-client/src/connection_manager.rs::deploy()`
- **Parser:** `rust-client/src/rholang_helpers.rs::convert_rholang_to_json()`

---

### **Environment Variables**

```bash
# .env
FIREFLY_HOST=localhost
FIREFLY_GRPC_PORT=40401
FIREFLY_HTTP_PORT=40403
FIREFLY_PRIVATE_KEY=your_private_key_here

# RGB storage contract URIs (from deployment)
RGB_STORAGE_STORE_CONTRACT=rho:id:abc123...
RGB_STORAGE_GET_CONTRACT=rho:id:def456...
RGB_STORAGE_SEARCH_BY_TICKER=rho:id:ghi789...
RGB_STORAGE_STORE_ALLOCATION=rho:id:jkl012...
RGB_STORAGE_GET_ALLOCATION=rho:id:mno345...
RGB_STORAGE_RECORD_TRANSITION=rho:id:pqr678...
RGB_STORAGE_GET_TRANSITION=rho:id:stu901...
```

---

### **Testing Checklist**

When working with F1r3fly integration, verify:

- [ ] Contract deployed with `insertSigned` (not just exploratory deploy)
- [ ] Registry URIs saved and accessible
- [ ] Phlo limit set to 10 billion (or higher)
- [ ] Complex queries use HTTP API
- [ ] Simple deploys use gRPC API
- [ ] `convert_rholang_to_json()` used for all HTTP responses
- [ ] Error handling for both "not found" and "parse error" cases

---

### **Common Errors and Solutions**

#### **Error: "Contract not found"**
- **Cause:** Using contract URI instead of registry URI
- **Solution:** Deploy with `insertSigned`, use registry URI from response

#### **Error: "Insufficient phlo"**
- **Cause:** Phlo limit too low
- **Solution:** Increase to 10 billion or higher

#### **Error: "expected value at line 1 column 1"**
- **Cause:** Trying to parse gRPC simplified string as JSON
- **Solution:** Use HTTP API for complex queries

#### **Error: "Complex expression with N fields"**
- **Cause:** gRPC returned simplified response
- **Solution:** Switch to HTTP API

---

### **Future Improvements**

1. **Add registry URI caching**
   - Store URIs in database after deployment
   - Avoid re-deployment on restart

2. **Implement phlo estimation**
   - Analyze Rholang code complexity
   - Dynamically set phlo limit

3. **Add gRPC full JSON support**
   - Modify F1r3fly node to return full JSON via gRPC
   - Eliminate need for HTTP fallback

4. **Create deployment automation**
   - Script to deploy `rgb_state_storage.rho`
   - Automatically save registry URIs to `.env`

---

## Conclusion

These three challenges (registry URIs, phlo limits, HTTP vs gRPC) are **fundamental to working with F1r3fly**. Understanding them will save hours of debugging and enable robust RGB integration.

**Key principles:**
1. **Persistence requires registry URIs** (use `insertSigned`)
2. **Overprovision phlo** (10 billion is safe)
3. **Use HTTP for complex data** (gRPC for simple deploys)

When in doubt, refer to this document and the code examples in:
- `rust-client/src/connection_manager.rs`
- `wallet/src/firefly/client.rs`
- `rust-client/src/rholang_helpers.rs`

---

**Document Version:** 1.0  
**Last Updated:** November 6, 2025  
**Maintainer:** F1r3fly-RGB Team

